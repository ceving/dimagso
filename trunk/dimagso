#! /usr/bin/perl -w
##
## Dimagso - A tool to sort digital images
##
## Time-stamp: <2009-04-08 17:09:26 szi>
##
## Sascha Ziemann <ceving@gmail.com>
##
##
## DOCUMENTATION
## =============
##
## The program is divided in the following packages.
##
## The default package for Perl programs:
##
##   main                       - Start of the program.
##
## Packages for application specific purposes:
##
##   Dimagso                    - The application itself.
##
##   Dimagso::MainWindow        - Main window of the application.
##   Dimagso::MenuBar           - Menu bar for the application.
##   Dimagso::ToolBar           - Tool bar for the application.
##   Dimagso::StatusBar         - Status bar for the application.
##   Dimagso::SourceIconView    - Icon view to display images.
##   Dimagso::DateSelection     - Selection for the date.
##   Dimagso::DirChooserButton  - Selection of a directory.
##   Dimagso::HideSelection     - Selection what should be hidden.
##   Dimagso::SortSelection     - Selection how to sort.
##   Dimagso::SelectAllButton   - Button to select all images.
##   Dimagso::SelectNoneButton  - Button to remove selection.
##   Dimagso::CreateJobButton   - Button to create a new job.
##   Dimagso::AddToJobButton    - Button to add to an existing job.
##   Dimagso::JobList           - List of defined jobs.
##   Dimagso::WorkList          - List of work to be done.
##   Dimagso::WorkProgress      - Progress meter for the work.
##   Dimagso::RenameButton      - Button to rename the images.
##   Dimagso::CopyButton        - Button to copy the images.
##   Dimagso::MoveButton        - Button to move the images.
##
##   Dimagso::AboutDialog       - About dialgo.
##   Dimagso::JobDialog         - Job dialog.
##
## Packages for GTK+ specific purposes:
##
##   LabeledWidgetArray         - Align widgets and labels.
##
## Packages for general purposes:
##
##   Config                     - Read and write configuration data.
##   Sexpr                      - Read, write and evaluate simple expressions.
##   NamedObject                - Create named objects.
##
## The order of the packages in this file is a bit different, beacuse
## all packages are within one file.  This makes it neccessary, that
## the packages which are used by other packages have to be defined
## first.  Practically this means that the packages main and Dimagso,
## which need the other packages, are at the end of the file, while
## the basic general purpose packages are at the beginning.
##



######################################################################
##
## Read and write configuration data
##

package AppConfig;

use strict;

sub new
{
    my $class = shift;
    my %args  = @_;
    my $self  = {};
    
    $self->{TREE} = defined $args{tree} && ref $args{tree} eq 'HASH' ? $args{tree} : {};
    $self->{FILENAME} = $args{filename};

    bless $self, $class;
    return $self;
}

sub DESTROY
{
    my $self = shift;
    $self->write;
    return undef;
}

#
# Set or get the whole configuration tree
#
sub tree
{
    my $self = shift;
    $self->{TREE} = shift if @_;
    return $self->{TREE};
}

#
# Traverse the whole configuration tree and apply action to each leaf.
#
sub traverse
{
    my $self = shift;
    my ($action) = @_;

    my $rec_traverse;

    # nested functions are globally visible so we use an anonymous
    # function.
    $rec_traverse = sub 
    {
	my ($tree, $path) = @_;
	
	foreach my $key (sort keys %$tree)
	{
	    if (ref($tree->{$key}) eq 'HASH') {
		&$rec_traverse ($tree->{$key}, [@$path, $key]);
	    } else {
		&$action ([@$path, $key], $tree->{$key}); 
	    }
	}
    };
    &$rec_traverse ($self->{TREE}, []);

    return undef;
}

#
# Set a node in the configuration tree.
#
sub set 
{
    my $self = shift;
    my ($path, $value) = @_;

    my $rec_set;

    $rec_set = sub
    {
	my ($tree, $path) = @_;

	my $key = shift @$path;
	if (scalar (@$path) == 0) {
	    $tree->{$key} = $value;
	} else {
	    $tree->{$key} = {} unless exists $tree->{$key};
	    &$rec_set ($tree->{$key}, $path);
	}
    };
    &$rec_set ($self->{TREE}, $path);

    return undef;
}

#
# Get the value of a node from the configuration tree.
#
sub get
{
    my $self = shift;
    my ($path) = @_;

    my $rec_get;

    $rec_get = sub
    {
	my ($tree, $path) = @_;

	my $key = shift @$path;
	if (scalar (@$path) == 0) {
	    return $tree->{$key};
	} else {
	    &$rec_get ($tree->{$key}, $path);
	}
    };
    return &$rec_get ($self->{TREE}, $path);
}

#
# Write the whole configuration tree into a file.
#
sub write
{
    my $self = shift;
    my %args = @_;

    $self->{FILENAME} = $args{filename} if defined $args{filename};

    open (FILE, '>', $self->{FILENAME}) 
	|| die "Can not open output file '" . $self->{FILENAME} . "'";

    $self->traverse (sub { my ($path, $value) = @_;
			   $value =~ s/(\\|")/\\$1/g;
			   print FILE 
			       join ('.', @$path), ' "',
			       $value, "\"\n" });
    close (FILE);
     
    return undef;
}

#
# Read the whole configuration tree from a file.
#
sub read
{
    my $self = shift;
    my %args = @_;

    $self->{FILENAME} = $args{filename} if defined $args{filename};

    # Read file into buffer
    open (FILE, '<', $self->{FILENAME})
	|| die "Can not open input file '" . $self->{FILENAME} . "'";
    my $buffer = '';
    while (<FILE>) { $buffer .= $_ }
    close (FILE);

    # Init tree
    $self->{TREE} = {};

    # Parse buffer
    my %tokens =
	grep { defined $_ && $_ ne '' && $_ ne "\n" }
        split (/(^[A-Za-z0-9_.-]+)|"((?:\\.|[^"])+)"|[\s\n]+/mx, $buffer);
    
    # Store unqoted values in tree
    foreach my $key (sort keys %tokens)
    {
	my $value = $tokens{$key};
	$value =~ s/\\(.)/$1/g;
	my $path = [split (/\./, $key)];
	$self->set ($path, $value);
    }

    return undef;
}



######################################################################
##
## Parse, dump and evaluate simple expressions
##

package Sexpr;

use strict;
use Carp;


sub new 
{
    my $class = shift;

    my $self = {};
    $self->{TREE} = {};  # named parse trees
    $self->{GENV} = {};  # global environment

    bless $self, $class;

    $self->parse (@_);

    return $self;
}

sub parse
{
    my $self = shift;
    my %args = @_;

    foreach (keys %args)
    {
	my $string = $args{$_};
	$self->{TREE}->{$_} = parse_list (\$string);
    }
    return undef;
}

sub stringify
{
    my $self = shift;

    return map { dump_list ($self->{TREE}->{$_}) } @_;
}

sub define
{
    my $self = shift;
    my %args = @_;

    foreach (keys %args)
    {
	$self->{GENV}->{$_} = $args{$_};
    }
    return undef;
}

sub evaluate
{
    my $self = shift;
    my %args = @_;
    
    my @result = ();
    foreach (keys %args)
    {
	croak "Rule '$_' undefined." unless defined $self->{TREE}->{$_};
	my $rule = $self->{TREE}->{$_};
	my $env  = $args{$_};

	my $str = evaluate_list ($rule, $self->{GENV}, $env);

	push @result, $str;
    }
    return @result;
}

sub parse_token
{
    my ($str_r) = @_;

    $$str_r =~ s/^[\s\n]+//s;

    return undef if $$str_r =~ /^$/s;

    if ($$str_r =~ s/^"((?:\\.|[^"])+)"//s) {
    	return { type => 'string',
		 value => $1 };
    }
    elsif ($$str_r =~ s/^([a-zA-Z0-9_][a-zA-Z0-9_.:\/\$\&\?*!#+-]*)//) {
	return { type => 'symbol', 
		 value => $1 };
    }
    elsif ($$str_r =~ s/^\(//) {
	return { type => 'opening-parenthesis' };
    }
    elsif ($$str_r =~ s/^\)//) {
	return { type => 'closing-parenthesis' };
    }
    else { die "Invalid token '".substr ($$str_r, 0, 10)."'" }
}

sub parse_list
{
    my ($str_r, $without_parenthesis) = @_;
    
    my @list = ();
    my $token;

    unless ($without_parenthesis) 
    {
	$token = parse_token ($str_r);
	die "Expecting opening parenthesis. Got '".%$token."'." 
	    unless $token->{type} eq 'opening-parenthesis';
    }
    while ($token = parse_token ($str_r))
    {
	if ($token->{type} eq 'opening-parenthesis')
	{
	    push @list, parse_list ($str_r, 1);
	}
	elsif ($token->{type} eq 'closing-parenthesis')
	{
	    return \@list;
	}
	else 
	{ 
	    push @list, $token 
	}
    }
    die "Expecting closing parenthesis. Got '".%$token."'.";
}

sub dump_token
{
    my ($token) = @_;

    if ($token->{type} eq 'string') {
	return '"'.$token->{value}.'"',
    }
    elsif ($token->{type} eq 'symbol') {
	return $token->{value};
    }
    else { croak "Unknown token type." }
}

sub dump_list
{
    my ($list) = @_;

    if (ref ($list) eq 'ARRAY')
    {
	my @result = ();

	foreach (@$list)
	{
	    if (ref ($_) eq 'HASH') {
		push @result, dump_token ($_);
	    }
	    elsif (ref ($_) eq 'ARRAY') {
		push @result, dump_list ($_);
	    }
	    else { croak "Invalid element" }
	}
	return '(' . join (' ', @result) . ')';
    }
    else { croak "Invalid argument" }
}

sub evaluate_token
{
    my ($token, $genv, $lenv) = @_;

    if ($token->{type} eq 'string') {
	return $token->{value},
    }
    elsif ($token->{type} eq 'symbol') {
	return $lenv->{$token->{value}} if defined $lenv->{$token->{value}};
	return $genv->{$token->{value}} if defined $genv->{$token->{value}};
	croak "Symbol '".$token->{value}."' undefined."
    }
    else { croak "Unknown token type." }
}

sub evaluate_list
{
    my ($list, $genv, $lenv) = @_;

    if (ref ($list) eq 'ARRAY')
    {
	my @result = ();

	foreach (@$list)
	{
	    if (ref ($_) eq 'HASH') {
		push @result, evaluate_token ($_, $genv, $lenv);
	    }
	    elsif (ref ($_) eq 'ARRAY') {
		push @result, evaluate_list ($_, $genv, $lenv);
	    }
	    else { die "Invalid element." }
	}

	my $func = shift @result;
	my $str = &$func (@result);
	
	return $str;
    }
    else { croak "Invalid argument." }
}



######################################################################
##
##  Class for named objects
##

package NamedObject;

use strict;
use Carp;

my %OBJECT_BY_REFERENCE = ();
my %OBJECT_BY_NAME      = ();

sub name_object
{
    my $self = shift;
    my $name = shift;

    croak "Name argument undefined" unless defined $name;

    delete ($OBJECT_BY_NAME{$name})
	if exists ($OBJECT_BY_NAME{$name});
    $OBJECT_BY_REFERENCE{$self} = $name;
    $OBJECT_BY_NAME{$name} = $self;
    
    return undef;
}

sub object_name
{
    my $self = shift;
    return $OBJECT_BY_REFERENCE{$self};
}

sub object_by_name
{
    my $self = shift;
    my $name = shift;

    croak "Name argument undefined" unless defined $name;
    
    return $OBJECT_BY_NAME{$name};
}

sub DESTROY
{
    my $self = shift;
    my $name = $OBJECT_BY_REFERENCE{$self};
    delete $OBJECT_BY_REFERENCE{$self};
    delete $OBJECT_BY_NAME{$name};
    return undef;
}



######################################################################
##
##  Widget to display a row of labeled widgets
##

package LabeledWidgetArray;

use strict;
use Glib qw(TRUE FALSE);
use Gtk2;
use base qw(Gtk2::Table);

sub new
{
    my $class = shift;
    my %args = @_;

    die "Argument orientation missing" unless defined $args{orientation};
    die "Invalid orientation" unless 
	$args{orientation} eq 'horizontal' || $args{orientation} eq 'vertical';
    die "Argument size missing" unless defined $args{size};
    $args{homogeneous} = FALSE unless defined $args{homogeneous};

    my $self;
    if ($args{orientation} eq 'horizontal')
    {
	$self = Gtk2::Table->new (1, $args{size} * 2, $args{homogeneous});
    }
    elsif ($args{orientation} eq 'vertical')
    {
	$self = Gtk2::Table->new ($args{size}, 2, $args{homogeneous});
	$self->set_row_spacings (5);
    }
    else { die "unknown orientation" }

    $self->set_col_spacings (5);

    $self->{ORIENTATION} = $args{orientation};
    $self->{CURSOR}      = 0;

    bless $self, $class;
    return $self;
}

sub add_labeled_widget 
{
    my $self = shift;
    my ($text, $widget) = @_;

    my $label = Gtk2::Label->new ($text);
    $label->set_property (xalign => 0);

    if ($self->{ORIENTATION} eq 'horizontal')
    {
	# Create label
	$self->attach_defaults ($label,
				$self->{CURSOR}, $self->{CURSOR}+1, 
				0, 1);
	$self->{CURSOR} += 1;
	
	# Add widget
	$self->attach_defaults ($widget,
				$self->{CURSOR}, $self->{CURSOR}+1, 
				0, 1);
	
	# Add additional space between the labeled widgets
	$self->set_col_spacing ($self->{CURSOR}, 10);
	
	$self->{CURSOR} += 1;
    }
    elsif ($self->{ORIENTATION} eq 'vertical')
    {
	# Create label
	$self->attach_defaults ($label,
				0, 1,
				$self->{CURSOR}, $self->{CURSOR}+1);
	# Add widget
	$self->attach_defaults ($widget,
				1, 2,
				$self->{CURSOR}, $self->{CURSOR}+1);
	$self->{CURSOR} += 1;
    }
    else { die "unknown orientation" }

    return undef;
}



######################################################################
##
##  Dimagso Menu Bar
##

package Dimagso::MenuBar;

use strict;
use Carp;
use Gtk2;
use base qw(Gtk2::MenuBar);

sub new
{
    my $class = shift;
    my $self = Gtk2::MenuBar->new;
    bless $self, $class;
    return $self;
}

sub add_menuitem
{
    my $menu = shift;
    my $definition = shift;

    my $item = exists $definition->{icon} ?
	Gtk2::ImageMenuItem->new_from_stock ($definition->{icon}) :
	Gtk2::MenuItem->new_with_mnemonic ($definition->{label});
    $menu->append ($item);

    if (exists $definition->{menu}) {
	my $submenu = Gtk2::Menu->new;
	$item->set_submenu ($submenu);
	foreach my $def (@{$definition->{menu}}) {
	    add_menuitem ($submenu, $def); } }
    elsif (exists $definition->{action}) {
	$item->signal_connect (activate => $definition->{action}); }
    else {
	croak "No menu and no action attribute."; }

    return undef;
}

sub define
{
    my $self = shift;
    my $definition = shift;

    foreach my $def (@$definition) {
	add_menuitem ($self, $def); }
 
   return undef;
}



######################################################################
package Dimagso::ToolBar;

use strict;
use Gtk2;
use base qw(Gtk2::Toolbar);

sub new
{
    my $class = shift;
    my $self = Gtk2::Toolbar->new;
    bless $self, $class;
    return $self;
}

sub define
{
    my $self = shift;
    my $toolbar_definition = shift;

    foreach my $toolbar_item (@$toolbar_definition)
    {
	my $item = Gtk2::ToolButton->new_from_stock ($toolbar_item->{stock});
	$self->insert ($item, -1);
	$item->signal_connect (clicked => $toolbar_item->{action});
    }
    return undef;
}



######################################################################
package Dimagso::StatusBar;

use strict;
use Glib qw(TRUE FALSE);
use Gtk2;
use base qw(Gtk2::Statusbar);

sub new
{
    my $class = shift;
    my $self = Gtk2::Statusbar->new;
    bless $self, $class;

    $self->set_property ('has-resize-grip', FALSE);

    return $self;
}

sub make_logger
{
    my $self = shift;
    my ($context) = @_;

    my $context_id = $self->get_context_id ($context || '');

    return sub {
	$self->pop ($context_id); # we do not need the stack
	$self->push ($context_id, join ('', @_));
    };
}



######################################################################
##
##  Dimagso About Dialog
##

package Dimagso::AboutDialog;

use strict;
use Gtk2;
use base qw(Gtk2::AboutDialog);

sub show
{
    my $class = shift;
    my $self = Gtk2::AboutDialog->new;
    bless $self, $class;

    $self->set_program_name ('Dimagso');
    $self->set_version (Dimagso->version);
    $self->set_copyright ('(c) Sascha Ziemann');
    $self->set_comments ('A tool to sort digital images.');
    $self->set_website ('http://vs301.hello-server.com/~szi/computer/');
    $self->run;
    $self->destroy;

    return undef;
}



######################################################################
##
##  Simple List Store
##

package SimpleListStore;

use strict;
use Glib qw(TRUE FALSE);
use Gtk2;
use base qw(Gtk2::ListStore);
use Carp;

sub new
{
    my $class = shift;
    my $types = shift;
    my $self = Gtk2::ListStore->new (@$types);
    bless $self, $class;
    $self->append_rows (@_) if @_;
    return $self;
}

sub append_rows
{
    my $self = shift;
    my @rows = @_;

    foreach my $row (@rows)
    {
	my $i = 0;
	$self->set ($self->append, map {$i++, $_} @$row); 
    }
    return undef;
}



######################################################################
package Dimagso::JobDialog;

use strict;
use Gtk2;
use base qw(Gtk2::Dialog);

sub show
{
    my $class = shift;
    my %args = @_;

    my $self = Gtk2::Dialog->new_with_buttons
	('Create a new job',
	 Dimagso::window(),
	 [qw(modal destroy-with-parent)],
	 'gtk-ok'     => 'accept',
	 'gtk-cancel' => 'reject');
    bless $self, $class;

    $self->set_default_response ('accept');

    # Create layout
    my $table = LabeledWidgetArray->new 
	(orientation => 'vertical',
	 size        => 3);
    $self->vbox->add ($table);
    $table->set_border_width (5);

    # Create job description selection
#    my %jobs = %{Dimagso::config()->{jobs}->{recent}};
#    my $job_list = SimpleListStore->new
#	([qw(Glib::String Glib::Int)],
#	 map {[$jobs{$_}, $_]} sort { $jobs{$a} cmp $jobs{$b} } keys %jobs);
#    my $job_combo = Gtk2::ComboBoxEntry->new ($job_list, 0);

    # Create rule selection
    my $job_combo = Gtk2::ComboBoxEntry->new_text;
    foreach (sort values %{Dimagso::config()->{jobs}->{recent}}) {
	$job_combo->append_text ($_);
    }

    # Create directory selection
    my $directory_combo = Gtk2::ComboBoxEntry->new_text;
    foreach (sort values %{Dimagso::config()->{dirs}->{recent}}) {
	$directory_combo->append_text ($_);
    }
    
    # Create rule selection
    my $rule_combo = Gtk2::ComboBoxEntry->new_text;
    foreach (sort map { $_->{name} } values %{Dimagso::config()->{rules}->{recent}}) {
	$rule_combo->append_text ($_);
    }

    # Layout widgets
    $table->add_labeled_widget ('Job description:',       $job_combo);
    $table->add_labeled_widget ('Destination directory:', $directory_combo);
    $table->add_labeled_widget ('Transformation rule:',   $rule_combo);

    # Open dialog box
    $self->vbox->show_all;
    my $result = $self->run;

    if ($result eq 'accept')
    {
	# Add job
	print 
	    "Description: '", $job_combo->get_active_text, "'\n",
	    "Directory:   '", $directory_combo->get_active_text, "'\n",
	    "Rule:        '", $rule_combo->get_active_text, "'\n";
    }

    $self->destroy;
    return undef;
}



######################################################################
##
##  Object for the source icons
##

package Dimagso::SourceIconView;

use strict;
use Glib qw(TRUE FALSE);
use Gtk2;
use base qw(Gtk2::IconView);
use Image::ExifTool;


sub new
{
    my $class = shift;
    my $self  = Gtk2::IconView->new;

    my %args = @_;

    $self->{DIRECTORY} = $args{directory};
    $self->{SET_DATES} = $args{set_dates}; # function to update the list of dates

    $self->{ATTRIBUTES} = 
    {thumbnail => { column => 0,
		    type   => 'Gtk2::Gdk::Pixbuf' },
     filename  => { column => 1,
		    type   => 'Glib::String' },
     tooltip   => { column => 2,
		    type   => 'Glib::String' },
     datetime  => { column => 3,
		    type   => 'Glib::String' },
     date      => { column => 4,
		    type   => 'Glib::String' },
     jobid     => { column => 5,
		    type   => 'Glib::Int' }};

    # Create liststore for thumbnail icons
    $self->{LISTSTORE} = Gtk2::ListStore->new 
	('Gtk2::Gdk::Pixbuf', # 0 thumbnail
	 'Glib::String',      # 1 filename
	 'Glib::String',      # 2 tooltip
	 'Glib::String',      # 3 datetime
	 'Glib::String',      # 4 date
	 'Glib::Int',         # 5 job id
	);
    
    # Sort list
    $self->{LISTSTORE}->set_sort_column_id 
	($self->{ATTRIBUTES}->{datetime}->{column}, 
	 'ascending');
    
    # Create a filter for the date
    $self->{DATE}     = undef; # the date for which icons should be shown
    $self->{LISTVIEW} = Gtk2::TreeModelFilter->new ($self->{LISTSTORE});
    $self->{LISTVIEW}->set_visible_func 
	( sub { 
	    return TRUE unless defined $self->{DATE};
	    my ($model, $iter) = @_;
	    my $date = $model->get ($iter, 4);
	    return TRUE if defined $date && ($date eq $self->{DATE});
	    return FALSE;
	  } );
    
    # Create iconview
    $self->set_model ($self->{LISTVIEW});
    $self->set_pixbuf_column (0);
    $self->set_text_column (1);
    $self->set_tooltip_column (2);
    $self->set_selection_mode ('multiple');
    
    bless $self, $class;
    return $self;
}

#sub set_logger
#{
#    my $self = shift;
#    $self->{LOGGER} = shift;
#    return undef;
#}

sub set_date
{
    my $self = shift;

    my $date = shift;
    $date = undef if defined $date && $date eq 'any';
    $self->{DATE} = $date;
    $self->{LISTVIEW}->refilter;

    return undef;
}

sub sort_by
{
    my $self = shift;
    my ($key, $order) = @_;

    $self->{LISTSTORE}->set_sort_column_id 
	($self->{ATTRIBUTES}->{$key}->{column}, 
	 $order);
}

sub get_directory
{
    my $self = shift;
    return $self->{DIRECTORY};
}

sub get_selected_files 
{
    my $self = shift;

    my @paths = $self->get_selected_items;
    my @iters = map { $self->{LISTVIEW}->get_iter ($_) } @paths;
    my @values = map { $self->{DIRECTORY} . '/' . $self->{LISTVIEW}->get ($_, 1) } @iters;
    return \@values;
}

sub read_directory
{
    my $self = shift;
    my ($dir) = @_;

    my %dates = ();

    # Remove old list
    $self->{LISTSTORE}->clear;
    
    # Read directory
    opendir (DIR, $dir) || die "Can not open direcotry '$dir'";
    my @files = grep { -f "$dir/$_" } readdir (DIR);
    closedir (DIR);

    # Add new files
    my $imagec = 0;
    foreach my $filename (@files)
    {
	# Read EXIF thumbnail and data
	my $exif = Image::ExifTool->new;
	my $info = $exif->ImageInfo 
	    ($filename, 
	     'ThumbnailImage', 'Model', 'LensType', 
	     'FocalLength', 'ExposureTime', 'FNumber', 'ISO', 
	     'DateTimeOriginal', 'SubSecTimeOriginal');
	next if scalar keys %$info == 0;
	my $thumb = ${$info->{ThumbnailImage}};
	my ($date, $time) = split (/ /, $info->{DateTimeOriginal});
	$date =~ tr/:/-/;
	$dates{$date} = 1;
	$time .= '.'.$info->{SubSecTimeOriginal} if exists $info->{SubSecTimeOriginal};
	my $tooltip = "$date $time\n$info->{Model}\n$info->{LensType}\n"
	    ."$info->{FocalLength}, ISO $info->{ISO}, "
	    ."f/$info->{FNumber}, $info->{ExposureTime}s";
	my $datetime = "$date$time";
	$datetime =~ s/[.:-]+//g;
	
	# Create pixbuf for thumbnail
	my $loader = Gtk2::Gdk::PixbufLoader->new;
	$loader->write ($thumb);
	$loader->close;
	my $pixbuf = $loader->get_pixbuf;
	
	# Add pixbuf to liststore
	my $iter = $self->{LISTSTORE}->append;
	$self->{LISTSTORE}->set 
	    ($iter,
	     0, $pixbuf,
	     1, $filename,
	     2, $tooltip,
	     3, $datetime,
	     4, $date,
	     5, -1);  # default for no job id

	# Increment image counter
	$imagec++;
    }

    my @datelist = sort keys %dates;
    &{$self->{SET_DATES}}(@datelist);

    $self->{DIRECTORY} = $dir;

    # Notify user
    my $datec = scalar @datelist;
    if ($datec == 0) {
	#&{$self->{LOGGER}}("Did not find any images with EXIF data in directory '$dir'.");
	Dimagso::logger ("Did not find any images with EXIF data in directory '$dir'.");
    } else {
	#&{$self->{LOGGER}}("Found $imagec images taken on $datec different days in directory '$dir'.");
	Dimagso::logger ("Found $imagec images taken on $datec different days in directory '$dir'.");
    }

    return undef;
}

sub set_set_dates
{
    my $self = shift;
    $self->{SET_DATES} = shift;
}



######################################################################
##
##  Widget to display a date selection
##

package Dimagso::DateSelection;

use strict;
use Glib qw(TRUE FALSE);
use Gtk2;
use base qw(Gtk2::ComboBox);

sub new
{
    my $class = shift;
    my $self  = Gtk2::ComboBox->new_text (@_);
    bless $self, $class;
    return $self;
}

sub set_dates
{
    my $self = shift;
    
    $self->get_model->clear;
    foreach ('any', @_)
    {
	$self->append_text ($_);
    }
    $self->set_active (0);
}



######################################################################
package Dimagso::DirChooserButton;

use strict;
use Gtk2;
use base qw(Gtk2::FileChooserButton);

sub new
{
    my $class = shift;
    my %args = @_;
    my $self = Gtk2::FileChooserButton->new ('Select a folder', 
					     'select-folder');
    bless $self, $class;
    return $self;
}



######################################################################
package Dimagso::HideSelection;

use strict;
use Gtk2;
use base qw(Gtk2::ComboBox);

sub new
{
    my $class = shift;
    my $self = Gtk2::ComboBox->new_text;
    bless $self, $class;
    $self->append_text ('assigned');
    $self->append_text ('none');
    $self->set_active (0);
    return $self;
}



######################################################################
package Dimagso::SortSelection;

use strict;
use Gtk2;
use base qw(Gtk2::ComboBox);

sub new
{
    my $class = shift;
    my $self = Gtk2::ComboBox->new_text;
    bless $self, $class;
    $self->append_text ('Date');
    $self->append_text ('File name');
    $self->set_active (0);
    return $self;
}



######################################################################
package Dimagso::SelectAllButton;

use strict;
use Gtk2;
use base qw(Gtk2::Button);

sub new
{
    my $class = shift;
    my $self = Gtk2::Button->new_with_label ('Select all');
    bless $self, $class;
    return $self;
}



######################################################################
package Dimagso::SelectNoneButton;

use strict;
use Gtk2;
use base qw(Gtk2::Button);

sub new
{
    my $class = shift;
    my $self = Gtk2::Button->new_with_label ('Select none');
    bless $self, $class;
    return $self;
}



######################################################################
package Dimagso::CreateJobButton;

use strict;
use Gtk2;
use base qw(Gtk2::Button);

sub new
{
    my $class = shift;
    my $self = Gtk2::Button->new_with_label ('Create new job');
    bless $self, $class;
    return $self;
}



######################################################################
package Dimagso::AddToJobButton;

use strict;
use Gtk2;
use base qw(Gtk2::Button);

sub new
{
    my $class = shift;
    my $self = Gtk2::Button->new_with_label ('Add to job');
    bless $self, $class;
    return $self;
}



######################################################################
##
##  Widget for the job list
##

package Dimagso::JobList;

use strict;
use Glib qw(TRUE FALSE);
use Gtk2;
use base qw(Gtk2::SimpleList);

sub new
{
    my $class = shift;
    my $self =  Gtk2::SimpleList->new ('Job'           => 'int',
				       'Description'   => 'text',
				       'Directory'     => 'text',
				       'Renaming rule' => 'text',
				       'Files'         => 'int');
    $self->get_column (4)->get_cell_renderers()->set_property ('xalign', 1.0);
    $self->get_selection->set_mode ('browse');
    $self->signal_connect (row_activated => sub { print "change date\n" });

    # Fake data
    @{$self->{data}} = 
	( [ 1, 'Lenni ist wie ein Schwein', 
	    '/home/Gemeinsame Dateien/Foto/Original', 
	    '${EXIF:DateTimeOriginal:Year}/${EXIF:}-$', 
	    35 ],
	  [ 2, 'Ebay-Verkäufe', 
	    '/home/Gemeinsame Dateien/Foto/Original',
	    '${EXIF:DateTimeOriginal:Year}/${EXIF:}-$', 
	    5 ],
	  [ 3, 'Testbilder neues Objektiv', 
	    '/home/Gemeinsame Dateien/Foto/Original',
	    '${EXIF:DateTimeOriginal:Year}/${EXIF:}-$', 
	    21 ] );

    bless $self, $class;
    return $self;
}

sub add_job
{
    my $self = shift;
    return undef;
}

sub delete_job
{
    my $self = shift;
    return undef;
}

sub append_images
{
    my $self = shift;
    return undef;
}



######################################################################
##
##  Widget for the work list
##

package Dimagso::WorkList;

use strict;
use Glib qw(TRUE FALSE);
use Gtk2;
use base qw(Gtk2::SimpleList);

sub new
{
    my $class = shift;
    my $self =  Gtk2::SimpleList->new ('Job'           => 'int',
				       'Description'   => 'text',
				       'Directory'     => 'text',
				       'Renaming rule' => 'text',
				       'Files'         => 'int');
    bless $self, $class;

    $self->get_column (4)->get_cell_renderers()->set_property ('xalign', 1.0);
    $self->get_selection->set_mode ('browse');
    $self->signal_connect (row_activated => sub { print "change date\n" });

    # Fake data
    @{$self->{data}} = 
	( [ 1, 'Lenni ist wie ein Schwein', 
	    '/home/Gemeinsame Dateien/Foto/Original', 
	    '${EXIF:DateTimeOriginal:Year}/${EXIF:}-$', 
	    35 ],
	  [ 2, 'Ebay-Verkäufe', 
	    '/home/Gemeinsame Dateien/Foto/Original',
	    '${EXIF:DateTimeOriginal:Year}/${EXIF:}-$', 
	    5 ],
	  [ 3, 'Testbilder neues Objektiv', 
	    '/home/Gemeinsame Dateien/Foto/Original',
	    '${EXIF:DateTimeOriginal:Year}/${EXIF:}-$', 
	    21 ] );

    return $self;
}



######################################################################
##
##  Widget for the work progress bar
##

package Dimagso::WorkProgress;

use strict;
use Glib qw(TRUE FALSE);
use Gtk2;
use base qw(Gtk2::ProgressBar);

sub new
{
    my $class = shift;
    my $self = Gtk2::ProgressBar->new;
    return $self;
}



######################################################################
package Dimagso::RenameButton;

use strict;
use Gtk2;
use base qw(Gtk2::Button);

sub new
{
    my $class = shift;
    my $self = Gtk2::Button->new_with_label ('Rename');
    bless $self, $class;
    return $self;
}



######################################################################
package Dimagso::CopyButton;

use strict;
use Gtk2;
use base qw(Gtk2::Button);

sub new
{
    my $class = shift;
    my $self = Gtk2::Button->new_with_label ('Copy');
    bless $self, $class;
    return $self;
}



######################################################################
package Dimagso::MoveButton;

use strict;
use Gtk2;
use base qw(Gtk2::Button);

sub new
{
    my $class = shift;
    my $self = Gtk2::Button->new_with_label ('Move');
    bless $self, $class;
    return $self;
}



######################################################################
package Dimagso::MainWindow;

use strict;
use Glib qw(TRUE FALSE);
use Gtk2;
use base qw(Gtk2::Window);

my $default_width = 1024;
my $default_height = 768;

sub new
{
    my $class = shift;
    my $self = Gtk2::Window->new ('toplevel');
    $self->{ADDER} = {};
    bless $self, $class;

    $self->set_size_request ($default_width, $default_height);
    $self->signal_connect (delete_event => sub { return 0 });
    $self->signal_connect (destroy      => sub { Gtk2->main_quit });

    return $self;
}

sub layout_widgets 
{
    my $self = shift;
    my %widgets = @_;
   
    # The main window contains a vbox for all other widgets.

    my $window_vbox = Gtk2::VBox->new (FALSE, 0);
    $self->add ($window_vbox);

    # The vbox contains a menu bar, a tool bar, a hpaned for the rest
    # of the window and a status bar.

    my $hpaned = Gtk2::HPaned->new;

    $window_vbox->pack_start ($widgets{menubar},   FALSE, FALSE, 0);
    $window_vbox->pack_start ($widgets{toolbar},   FALSE, FALSE, 0);
    $window_vbox->pack_start ($hpaned,             TRUE,  TRUE,  0);
    $window_vbox->pack_start ($widgets{statusbar}, FALSE, FALSE, 0);

    # The horizontal paned contains a vbox on the left side and a
    # vertical paned on the right side.

    my $left_vbox = Gtk2::VBox->new (FALSE, 5);
    $left_vbox->set_border_width (5);
    my $vpaned = Gtk2::VPaned->new;

    $hpaned->add1 ($left_vbox);
    $hpaned->add2 ($vpaned);

    # The vbox on the left side contains a hbox for the selection
    # table, a scrolled list for the iconlist and a button box for the
    # buttons of the icon view.

    my $selection_hbox = Gtk2::HBox->new (FALSE, 0);

    my $left_scrolledw = Gtk2::ScrolledWindow->new (undef, undef);
    $left_scrolledw->set_size_request (540, 300);
    $left_scrolledw->set_shadow_type ('etched-in');
    $left_scrolledw->set_policy ('never', 'always');

    my $left_hbbox = Gtk2::HButtonBox->new;
    $left_hbbox->set_layout ('center');
    $left_hbbox->set_spacing (10);

    $left_vbox->pack_start ($selection_hbox, FALSE, FALSE, 0);
    $left_vbox->pack_start ($left_scrolledw, TRUE,  TRUE,  0);
    $left_vbox->pack_start ($left_hbbox,     FALSE, FALSE, 5);

    # The hbox for the selection table contains only the selection
    # table.

    my $selection_table = LabeledWidgetArray->new 
	(orientation => 'horizontal',
	 size        => 4);
    $selection_hbox->pack_start ($selection_table, FALSE, FALSE, 0);

    # The selection table contains the selection widgets for the
    # directory, date, hide status and sort attribute.

    $selection_table->add_labeled_widget ('Directory:', $widgets{dirchooser});
    $selection_table->add_labeled_widget ('Date:',      $widgets{datesel});
    $selection_table->add_labeled_widget ('Hide:',      $widgets{hidesel});
    $selection_table->add_labeled_widget ('Sort by:',   $widgets{sortsel});

    # The scrolled window contains the icon view for the images.

    $left_scrolledw->add ($widgets{iconview});

    # The button box contains the following buttons.

    $left_hbbox->add ($widgets{select_all_button});
    $left_hbbox->add ($widgets{select_none_button});
    $left_hbbox->add ($widgets{create_job_button});
    $left_hbbox->add ($widgets{add_to_job_button});

    # Vbox for the job list scrolled window and the button bar

    my $topright_vbox = Gtk2::VBox->new (FALSE, 5);
    $vpaned->add1 ($topright_vbox);
    $topright_vbox->set_border_width (5);

    # Scrolled window for the job list

    my $topright_scrolledw = Gtk2::ScrolledWindow->new;
    $topright_vbox->pack_start ($topright_scrolledw, TRUE, TRUE, 0);
    $topright_scrolledw->set_size_request (400, 200);
    $topright_scrolledw->set_shadow_type ('etched-in');
    $topright_scrolledw->set_policy ('automatic', 'always');

    # Listbox for the jobs in the top part of the Vpaned

    $topright_scrolledw->add ($widgets{joblist});

    # Buttons for the job list

    my $topright_hbbox = Gtk2::HButtonBox->new;
    $topright_vbox->pack_start ($topright_hbbox, FALSE, FALSE, 5);
    $topright_hbbox->set_layout ('center');
    $topright_hbbox->set_spacing (10);
    $topright_hbbox->add (Gtk2::Button->new_with_label ('Move up'));
    $topright_hbbox->add (Gtk2::Button->new_with_label ('Move down'));
    $topright_hbbox->add (Gtk2::Button->new_with_label ('Delete'));
    
    # Vbox for work list

    my $bottomright_vbox = Gtk2::VBox->new (FALSE, 5);
    $vpaned->add2 ($bottomright_vbox);
    $bottomright_vbox->set_border_width (5);
    
    # Scrolled window for the transformation rules of the work list

    my $bottomright_scrolledw = Gtk2::ScrolledWindow->new;
    $bottomright_vbox->pack_start ($bottomright_scrolledw, TRUE, TRUE, 0);
    $bottomright_scrolledw->set_size_request (400, 200);
    $bottomright_scrolledw->set_shadow_type ('etched-in');
    $bottomright_scrolledw->set_policy ('automatic', 'always');
    
    # Work list

    $bottomright_scrolledw->add ($widgets{worklist});
    
    # Progress bar for transformation

    $bottomright_vbox->pack_start ($widgets{workprogress}, FALSE, FALSE, 0);
    
    # Buttons for transformation list

    my $bottomright_hbbox = Gtk2::HButtonBox->new;
    $bottomright_vbox->pack_start ($bottomright_hbbox, FALSE, FALSE, 5);
    $bottomright_hbbox->set_layout ('center');
    $bottomright_hbbox->set_spacing (10);
    $bottomright_hbbox->add ($widgets{rename_button});
    $bottomright_hbbox->add ($widgets{copy_button});
    $bottomright_hbbox->add ($widgets{move_button});

    return undef;
}



######################################################################
##
##  Base package for the application
##

package Dimagso;

use strict;
use Getopt::Long;
use Error qw(:try :warndie);
use Gtk2 -init;
use Cwd qw(getcwd);


my $OPTIONS = {config_file => 'dimagso.cfg',
	       image_dir   => getcwd};
sub options { return $OPTIONS; }

my $VERSION = '0.1';
sub version { return $VERSION; }

#my $LOGGER = { my $msg; sub { $msg = join ('', @_) if @_; return $msg; }; }
my $LOGGER = sub { };
sub logger { return &$LOGGER(@_); }

my $CONFIG = undef;
sub config
{
    $CONFIG->set (@_) if @_;
    return $CONFIG->tree;
}
my $WINDOW = undef;
sub window { return $WINDOW; }

sub finish
{
    return sub {
	print map { $_, "\n" } @_;
	exit;
    };
}

sub read_options 
{
    GetOptions 
	('help' =>
	 finish ('Dimagso version ' . version,
		 'Options:',
		 '  --help      Display usage',
		 '  --version   Display version information'),
	 'version' => 
	 finish ('Dimagso version ', version),
	 'config-file' => \$OPTIONS->{config_file},
	 'image-dir'   => \$OPTIONS->{image_dir},
	) || die 'Can not read command line options.';
}

sub read_config
{
    $CONFIG = AppConfig->new (tree => {default => 1},
			      filename => $OPTIONS->{config_file});
    try { $CONFIG->read; }
    catch Error with {
	# Init configuration
	warn "Initializing a new configuration";
	$CONFIG->set ([qw (jobs recent 0)], 'Lennart eats like a pig');
	$CONFIG->set ([qw (jobs recent 1)], 'Macros of a bie');
	$CONFIG->set ([qw (jobs recent 2)], 'Christmas day 1');
	$CONFIG->set ([qw (jobs recent 3)], 'Christmas day 2');
	$CONFIG->set ([qw (dirs recent 0)], '/home/szi/Foto/Original');
	$CONFIG->set ([qw (dirs recent 1)], '/home/Gemeinsame Dateien/Foto/Original');
	$CONFIG->set ([qw (rules 0 name)], 'Move images');
	$CONFIG->set ([qw (rules 0 dir)],  '/home/Gemeinsame Dateien/Foto/Original');
	$CONFIG->set ([qw (rules 0 ren)],  '');
    };
    return undef;
}

sub create_gui
{
    # Create widgets
    $WINDOW = Dimagso::MainWindow->new;
    my %widgets = (menubar            => Dimagso::MenuBar->new,
		   toolbar            => Dimagso::ToolBar->new,
		   dirchooser         => Dimagso::DirChooserButton->new,
		   datesel            => Dimagso::DateSelection->new,
		   hidesel            => Dimagso::HideSelection->new,
		   sortsel            => Dimagso::SortSelection->new,
		   statusbar          => Dimagso::StatusBar->new,
		   iconview           => Dimagso::SourceIconView->new,
		   select_all_button  => Dimagso::SelectAllButton->new,
		   select_none_button => Dimagso::SelectNoneButton->new,
		   create_job_button  => Dimagso::CreateJobButton->new,
		   add_to_job_button  => Dimagso::AddToJobButton->new,
		   joblist            => Dimagso::JobList->new,
		   worklist           => Dimagso::WorkList->new,
		   workprogress       => Dimagso::WorkProgress->new,
		   rename_button      => Dimagso::RenameButton->new,
		   copy_button        => Dimagso::CopyButton->new,
		   move_button        => Dimagso::MoveButton->new,
	);
    $WINDOW->layout_widgets (%widgets);

    # Define logger
    my $logger = $widgets{statusbar}->make_logger;
    &$logger (logger);
    $LOGGER = $logger;

    # Interconnect the widgets

    $widgets{menubar}->define (
	[{ label => '_File',
	   menu  => 
	       [{ label => 'Empty',
		  action => sub { } },
		{ label  => '_Exec ute',
		  action => sub { },
		  icon   => 'gtk-execute' },
		{ label  => '_Apply',
		  action => sub { },
		  icon   => 'gtk-apply' },
		{ label  => '_Play',
		  action => sub { },
		  icon   => 'gtk-media-play' },
		{ label  => '_Jump',
		  action => sub { },
		  icon   => 'gtk-jump-to' },
		{ label  => '_Ok',
		  action => sub { },
		  icon   => 'gtk-ok' },
		{ label  => '_Quit',
		  action => sub { Gtk2->main_quit },
		  icon   => 'gtk-quit' }
	       ]},
	 { label => '_Options',
	   menu  => 
	       [{ label => '_Preferences',
		  action => sub {  },
		  icon   => 'gtk-preferences' },
		{ label => '_Manage recent...',
		  menu =>
		      [{ label => '_Jobs',
			 action => sub { print "Jobs\n" } },
		       { label => '_Directories',
			 action => sub { print "Dirs\n" } },
		       { label => '_Rules',
			 action => sub { print "Rules\n" } }
		      ]}
	       ]},
	 { label => '_Help',
	   menu  => 
	       [{ label => '_About',
		  action => sub { Dimagso::AboutDialog->show },
		  icon   => 'gtk-about' }
	       ]}
	]);

    $widgets{toolbar}->define
	([{ stock => 'gtk-about',
	    action => sub { Dimagso::AboutDialog->show } }
	 ]);

    $widgets{iconview}->set_set_dates 
	(sub { $widgets{datesel}->set_dates (@_) });

    $widgets{select_all_button}->signal_connect 
	(clicked => sub { $widgets{iconview}->select_all });
    $widgets{select_none_button}->signal_connect 
	(clicked => sub { $widgets{iconview}->unselect_all });
    $widgets{create_job_button}->signal_connect 
	(clicked => sub {
	    Dimagso::JobDialog->show
		(files  => $widgets{iconview}->get_selected_files);
	 });

    # Update icon view when date selection changes
    $widgets{dirchooser}->signal_connect (
	'current-folder-changed' => sub 
	{
	    my $dir = $widgets{dirchooser}->get_current_folder;
	    return if $widgets{iconview}->get_directory eq $dir;
	    $widgets{iconview}->read_directory ($dir);
	});
    $widgets{datesel}->signal_connect 
	(changed => sub { $widgets{iconview}->set_date ($widgets{datesel}->get_active_text) });
    $widgets{sortsel}->signal_connect
	(changed => sub { my %col = (0 => 'datetime', 
				     1 => 'filename');
			  $widgets{iconview}->sort_by ($col{$widgets{sortsel}->get_active},
					      'ascending') }),
    # Read directory
    $widgets{dirchooser}->set_current_folder ($OPTIONS->{image_dir});
    $widgets{iconview}->read_directory ($OPTIONS->{image_dir});

    return undef;
}

sub run
{
    $WINDOW->show_all;
    Gtk2->main;
}



######################################################################
package main;

use strict;

Dimagso::read_options;
Dimagso::read_config;
Dimagso::create_gui;

#use Data::Dumper;
#my $cfg = Dimagso::config;
#print Dumper ($cfg);
#exit;

Dimagso::run;
